// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CarlifeDeviceInfoProto.proto

#ifndef PROTOBUF_CarlifeDeviceInfoProto_2eproto__INCLUDED
#define PROTOBUF_CarlifeDeviceInfoProto_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace baidu {
namespace carlife {
namespace protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CarlifeDeviceInfoProto_2eproto();
void protobuf_AssignDesc_CarlifeDeviceInfoProto_2eproto();
void protobuf_ShutdownFile_CarlifeDeviceInfoProto_2eproto();

class CarlifeDeviceInfo;

// ===================================================================

class CarlifeDeviceInfo : public ::google::protobuf::Message {
 public:
  CarlifeDeviceInfo();
  virtual ~CarlifeDeviceInfo();

  CarlifeDeviceInfo(const CarlifeDeviceInfo& from);

  inline CarlifeDeviceInfo& operator=(const CarlifeDeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CarlifeDeviceInfo& default_instance();

  void Swap(CarlifeDeviceInfo* other);

  // implements Message ----------------------------------------------

  CarlifeDeviceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CarlifeDeviceInfo& from);
  void MergeFrom(const CarlifeDeviceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string os = 1;
  inline bool has_os() const;
  inline void clear_os();
  static const int kOsFieldNumber = 1;
  inline const ::std::string& os() const;
  inline void set_os(const ::std::string& value);
  inline void set_os(const char* value);
  inline void set_os(const char* value, size_t size);
  inline ::std::string* mutable_os();
  inline ::std::string* release_os();
  inline void set_allocated_os(::std::string* os);

  // optional string board = 2;
  inline bool has_board() const;
  inline void clear_board();
  static const int kBoardFieldNumber = 2;
  inline const ::std::string& board() const;
  inline void set_board(const ::std::string& value);
  inline void set_board(const char* value);
  inline void set_board(const char* value, size_t size);
  inline ::std::string* mutable_board();
  inline ::std::string* release_board();
  inline void set_allocated_board(::std::string* board);

  // optional string bootloader = 3;
  inline bool has_bootloader() const;
  inline void clear_bootloader();
  static const int kBootloaderFieldNumber = 3;
  inline const ::std::string& bootloader() const;
  inline void set_bootloader(const ::std::string& value);
  inline void set_bootloader(const char* value);
  inline void set_bootloader(const char* value, size_t size);
  inline ::std::string* mutable_bootloader();
  inline ::std::string* release_bootloader();
  inline void set_allocated_bootloader(::std::string* bootloader);

  // optional string brand = 4;
  inline bool has_brand() const;
  inline void clear_brand();
  static const int kBrandFieldNumber = 4;
  inline const ::std::string& brand() const;
  inline void set_brand(const ::std::string& value);
  inline void set_brand(const char* value);
  inline void set_brand(const char* value, size_t size);
  inline ::std::string* mutable_brand();
  inline ::std::string* release_brand();
  inline void set_allocated_brand(::std::string* brand);

  // optional string cpu_abi = 5;
  inline bool has_cpu_abi() const;
  inline void clear_cpu_abi();
  static const int kCpuAbiFieldNumber = 5;
  inline const ::std::string& cpu_abi() const;
  inline void set_cpu_abi(const ::std::string& value);
  inline void set_cpu_abi(const char* value);
  inline void set_cpu_abi(const char* value, size_t size);
  inline ::std::string* mutable_cpu_abi();
  inline ::std::string* release_cpu_abi();
  inline void set_allocated_cpu_abi(::std::string* cpu_abi);

  // optional string cpu_abi2 = 6;
  inline bool has_cpu_abi2() const;
  inline void clear_cpu_abi2();
  static const int kCpuAbi2FieldNumber = 6;
  inline const ::std::string& cpu_abi2() const;
  inline void set_cpu_abi2(const ::std::string& value);
  inline void set_cpu_abi2(const char* value);
  inline void set_cpu_abi2(const char* value, size_t size);
  inline ::std::string* mutable_cpu_abi2();
  inline ::std::string* release_cpu_abi2();
  inline void set_allocated_cpu_abi2(::std::string* cpu_abi2);

  // optional string device = 7;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 7;
  inline const ::std::string& device() const;
  inline void set_device(const ::std::string& value);
  inline void set_device(const char* value);
  inline void set_device(const char* value, size_t size);
  inline ::std::string* mutable_device();
  inline ::std::string* release_device();
  inline void set_allocated_device(::std::string* device);

  // optional string display = 8;
  inline bool has_display() const;
  inline void clear_display();
  static const int kDisplayFieldNumber = 8;
  inline const ::std::string& display() const;
  inline void set_display(const ::std::string& value);
  inline void set_display(const char* value);
  inline void set_display(const char* value, size_t size);
  inline ::std::string* mutable_display();
  inline ::std::string* release_display();
  inline void set_allocated_display(::std::string* display);

  // optional string fingerprint = 9;
  inline bool has_fingerprint() const;
  inline void clear_fingerprint();
  static const int kFingerprintFieldNumber = 9;
  inline const ::std::string& fingerprint() const;
  inline void set_fingerprint(const ::std::string& value);
  inline void set_fingerprint(const char* value);
  inline void set_fingerprint(const char* value, size_t size);
  inline ::std::string* mutable_fingerprint();
  inline ::std::string* release_fingerprint();
  inline void set_allocated_fingerprint(::std::string* fingerprint);

  // optional string hardware = 10;
  inline bool has_hardware() const;
  inline void clear_hardware();
  static const int kHardwareFieldNumber = 10;
  inline const ::std::string& hardware() const;
  inline void set_hardware(const ::std::string& value);
  inline void set_hardware(const char* value);
  inline void set_hardware(const char* value, size_t size);
  inline ::std::string* mutable_hardware();
  inline ::std::string* release_hardware();
  inline void set_allocated_hardware(::std::string* hardware);

  // optional string host = 11;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 11;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // optional string cid = 12;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 12;
  inline const ::std::string& cid() const;
  inline void set_cid(const ::std::string& value);
  inline void set_cid(const char* value);
  inline void set_cid(const char* value, size_t size);
  inline ::std::string* mutable_cid();
  inline ::std::string* release_cid();
  inline void set_allocated_cid(::std::string* cid);

  // optional string manufacturer = 13;
  inline bool has_manufacturer() const;
  inline void clear_manufacturer();
  static const int kManufacturerFieldNumber = 13;
  inline const ::std::string& manufacturer() const;
  inline void set_manufacturer(const ::std::string& value);
  inline void set_manufacturer(const char* value);
  inline void set_manufacturer(const char* value, size_t size);
  inline ::std::string* mutable_manufacturer();
  inline ::std::string* release_manufacturer();
  inline void set_allocated_manufacturer(::std::string* manufacturer);

  // optional string model = 14;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 14;
  inline const ::std::string& model() const;
  inline void set_model(const ::std::string& value);
  inline void set_model(const char* value);
  inline void set_model(const char* value, size_t size);
  inline ::std::string* mutable_model();
  inline ::std::string* release_model();
  inline void set_allocated_model(::std::string* model);

  // optional string product = 15;
  inline bool has_product() const;
  inline void clear_product();
  static const int kProductFieldNumber = 15;
  inline const ::std::string& product() const;
  inline void set_product(const ::std::string& value);
  inline void set_product(const char* value);
  inline void set_product(const char* value, size_t size);
  inline ::std::string* mutable_product();
  inline ::std::string* release_product();
  inline void set_allocated_product(::std::string* product);

  // optional string serial = 16;
  inline bool has_serial() const;
  inline void clear_serial();
  static const int kSerialFieldNumber = 16;
  inline const ::std::string& serial() const;
  inline void set_serial(const ::std::string& value);
  inline void set_serial(const char* value);
  inline void set_serial(const char* value, size_t size);
  inline ::std::string* mutable_serial();
  inline ::std::string* release_serial();
  inline void set_allocated_serial(::std::string* serial);

  // optional string codename = 17;
  inline bool has_codename() const;
  inline void clear_codename();
  static const int kCodenameFieldNumber = 17;
  inline const ::std::string& codename() const;
  inline void set_codename(const ::std::string& value);
  inline void set_codename(const char* value);
  inline void set_codename(const char* value, size_t size);
  inline ::std::string* mutable_codename();
  inline ::std::string* release_codename();
  inline void set_allocated_codename(::std::string* codename);

  // optional string incremental = 18;
  inline bool has_incremental() const;
  inline void clear_incremental();
  static const int kIncrementalFieldNumber = 18;
  inline const ::std::string& incremental() const;
  inline void set_incremental(const ::std::string& value);
  inline void set_incremental(const char* value);
  inline void set_incremental(const char* value, size_t size);
  inline ::std::string* mutable_incremental();
  inline ::std::string* release_incremental();
  inline void set_allocated_incremental(::std::string* incremental);

  // optional string release = 19;
  inline bool has_release() const;
  inline void clear_release();
  static const int kReleaseFieldNumber = 19;
  inline const ::std::string& release() const;
  inline void set_release(const ::std::string& value);
  inline void set_release(const char* value);
  inline void set_release(const char* value, size_t size);
  inline ::std::string* mutable_release();
  inline ::std::string* release_release();
  inline void set_allocated_release(::std::string* release);

  // optional string sdk = 20;
  inline bool has_sdk() const;
  inline void clear_sdk();
  static const int kSdkFieldNumber = 20;
  inline const ::std::string& sdk() const;
  inline void set_sdk(const ::std::string& value);
  inline void set_sdk(const char* value);
  inline void set_sdk(const char* value, size_t size);
  inline ::std::string* mutable_sdk();
  inline ::std::string* release_sdk();
  inline void set_allocated_sdk(::std::string* sdk);

  // optional int32 sdk_int = 21;
  inline bool has_sdk_int() const;
  inline void clear_sdk_int();
  static const int kSdkIntFieldNumber = 21;
  inline ::google::protobuf::int32 sdk_int() const;
  inline void set_sdk_int(::google::protobuf::int32 value);

  // optional string token = 22;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 22;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional string btaddress = 23;
  inline bool has_btaddress() const;
  inline void clear_btaddress();
  static const int kBtaddressFieldNumber = 23;
  inline const ::std::string& btaddress() const;
  inline void set_btaddress(const ::std::string& value);
  inline void set_btaddress(const char* value);
  inline void set_btaddress(const char* value, size_t size);
  inline ::std::string* mutable_btaddress();
  inline ::std::string* release_btaddress();
  inline void set_allocated_btaddress(::std::string* btaddress);

  // @@protoc_insertion_point(class_scope:com.baidu.carlife.protobuf.CarlifeDeviceInfo)
 private:
  inline void set_has_os();
  inline void clear_has_os();
  inline void set_has_board();
  inline void clear_has_board();
  inline void set_has_bootloader();
  inline void clear_has_bootloader();
  inline void set_has_brand();
  inline void clear_has_brand();
  inline void set_has_cpu_abi();
  inline void clear_has_cpu_abi();
  inline void set_has_cpu_abi2();
  inline void clear_has_cpu_abi2();
  inline void set_has_device();
  inline void clear_has_device();
  inline void set_has_display();
  inline void clear_has_display();
  inline void set_has_fingerprint();
  inline void clear_has_fingerprint();
  inline void set_has_hardware();
  inline void clear_has_hardware();
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_manufacturer();
  inline void clear_has_manufacturer();
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_product();
  inline void clear_has_product();
  inline void set_has_serial();
  inline void clear_has_serial();
  inline void set_has_codename();
  inline void clear_has_codename();
  inline void set_has_incremental();
  inline void clear_has_incremental();
  inline void set_has_release();
  inline void clear_has_release();
  inline void set_has_sdk();
  inline void clear_has_sdk();
  inline void set_has_sdk_int();
  inline void clear_has_sdk_int();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_btaddress();
  inline void clear_has_btaddress();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* os_;
  ::std::string* board_;
  ::std::string* bootloader_;
  ::std::string* brand_;
  ::std::string* cpu_abi_;
  ::std::string* cpu_abi2_;
  ::std::string* device_;
  ::std::string* display_;
  ::std::string* fingerprint_;
  ::std::string* hardware_;
  ::std::string* host_;
  ::std::string* cid_;
  ::std::string* manufacturer_;
  ::std::string* model_;
  ::std::string* product_;
  ::std::string* serial_;
  ::std::string* codename_;
  ::std::string* incremental_;
  ::std::string* release_;
  ::std::string* sdk_;
  ::std::string* token_;
  ::std::string* btaddress_;
  ::google::protobuf::int32 sdk_int_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(23 + 31) / 32];

  friend void  protobuf_AddDesc_CarlifeDeviceInfoProto_2eproto();
  friend void protobuf_AssignDesc_CarlifeDeviceInfoProto_2eproto();
  friend void protobuf_ShutdownFile_CarlifeDeviceInfoProto_2eproto();

  void InitAsDefaultInstance();
  static CarlifeDeviceInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// CarlifeDeviceInfo

// optional string os = 1;
inline bool CarlifeDeviceInfo::has_os() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CarlifeDeviceInfo::set_has_os() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CarlifeDeviceInfo::clear_has_os() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CarlifeDeviceInfo::clear_os() {
  if (os_ != &::google::protobuf::internal::kEmptyString) {
    os_->clear();
  }
  clear_has_os();
}
inline const ::std::string& CarlifeDeviceInfo::os() const {
  return *os_;
}
inline void CarlifeDeviceInfo::set_os(const ::std::string& value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void CarlifeDeviceInfo::set_os(const char* value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void CarlifeDeviceInfo::set_os(const char* value, size_t size) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CarlifeDeviceInfo::mutable_os() {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  return os_;
}
inline ::std::string* CarlifeDeviceInfo::release_os() {
  clear_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = os_;
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CarlifeDeviceInfo::set_allocated_os(::std::string* os) {
  if (os_ != &::google::protobuf::internal::kEmptyString) {
    delete os_;
  }
  if (os) {
    set_has_os();
    os_ = os;
  } else {
    clear_has_os();
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string board = 2;
inline bool CarlifeDeviceInfo::has_board() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CarlifeDeviceInfo::set_has_board() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CarlifeDeviceInfo::clear_has_board() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CarlifeDeviceInfo::clear_board() {
  if (board_ != &::google::protobuf::internal::kEmptyString) {
    board_->clear();
  }
  clear_has_board();
}
inline const ::std::string& CarlifeDeviceInfo::board() const {
  return *board_;
}
inline void CarlifeDeviceInfo::set_board(const ::std::string& value) {
  set_has_board();
  if (board_ == &::google::protobuf::internal::kEmptyString) {
    board_ = new ::std::string;
  }
  board_->assign(value);
}
inline void CarlifeDeviceInfo::set_board(const char* value) {
  set_has_board();
  if (board_ == &::google::protobuf::internal::kEmptyString) {
    board_ = new ::std::string;
  }
  board_->assign(value);
}
inline void CarlifeDeviceInfo::set_board(const char* value, size_t size) {
  set_has_board();
  if (board_ == &::google::protobuf::internal::kEmptyString) {
    board_ = new ::std::string;
  }
  board_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CarlifeDeviceInfo::mutable_board() {
  set_has_board();
  if (board_ == &::google::protobuf::internal::kEmptyString) {
    board_ = new ::std::string;
  }
  return board_;
}
inline ::std::string* CarlifeDeviceInfo::release_board() {
  clear_has_board();
  if (board_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = board_;
    board_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CarlifeDeviceInfo::set_allocated_board(::std::string* board) {
  if (board_ != &::google::protobuf::internal::kEmptyString) {
    delete board_;
  }
  if (board) {
    set_has_board();
    board_ = board;
  } else {
    clear_has_board();
    board_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bootloader = 3;
inline bool CarlifeDeviceInfo::has_bootloader() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CarlifeDeviceInfo::set_has_bootloader() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CarlifeDeviceInfo::clear_has_bootloader() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CarlifeDeviceInfo::clear_bootloader() {
  if (bootloader_ != &::google::protobuf::internal::kEmptyString) {
    bootloader_->clear();
  }
  clear_has_bootloader();
}
inline const ::std::string& CarlifeDeviceInfo::bootloader() const {
  return *bootloader_;
}
inline void CarlifeDeviceInfo::set_bootloader(const ::std::string& value) {
  set_has_bootloader();
  if (bootloader_ == &::google::protobuf::internal::kEmptyString) {
    bootloader_ = new ::std::string;
  }
  bootloader_->assign(value);
}
inline void CarlifeDeviceInfo::set_bootloader(const char* value) {
  set_has_bootloader();
  if (bootloader_ == &::google::protobuf::internal::kEmptyString) {
    bootloader_ = new ::std::string;
  }
  bootloader_->assign(value);
}
inline void CarlifeDeviceInfo::set_bootloader(const char* value, size_t size) {
  set_has_bootloader();
  if (bootloader_ == &::google::protobuf::internal::kEmptyString) {
    bootloader_ = new ::std::string;
  }
  bootloader_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CarlifeDeviceInfo::mutable_bootloader() {
  set_has_bootloader();
  if (bootloader_ == &::google::protobuf::internal::kEmptyString) {
    bootloader_ = new ::std::string;
  }
  return bootloader_;
}
inline ::std::string* CarlifeDeviceInfo::release_bootloader() {
  clear_has_bootloader();
  if (bootloader_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bootloader_;
    bootloader_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CarlifeDeviceInfo::set_allocated_bootloader(::std::string* bootloader) {
  if (bootloader_ != &::google::protobuf::internal::kEmptyString) {
    delete bootloader_;
  }
  if (bootloader) {
    set_has_bootloader();
    bootloader_ = bootloader;
  } else {
    clear_has_bootloader();
    bootloader_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string brand = 4;
inline bool CarlifeDeviceInfo::has_brand() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CarlifeDeviceInfo::set_has_brand() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CarlifeDeviceInfo::clear_has_brand() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CarlifeDeviceInfo::clear_brand() {
  if (brand_ != &::google::protobuf::internal::kEmptyString) {
    brand_->clear();
  }
  clear_has_brand();
}
inline const ::std::string& CarlifeDeviceInfo::brand() const {
  return *brand_;
}
inline void CarlifeDeviceInfo::set_brand(const ::std::string& value) {
  set_has_brand();
  if (brand_ == &::google::protobuf::internal::kEmptyString) {
    brand_ = new ::std::string;
  }
  brand_->assign(value);
}
inline void CarlifeDeviceInfo::set_brand(const char* value) {
  set_has_brand();
  if (brand_ == &::google::protobuf::internal::kEmptyString) {
    brand_ = new ::std::string;
  }
  brand_->assign(value);
}
inline void CarlifeDeviceInfo::set_brand(const char* value, size_t size) {
  set_has_brand();
  if (brand_ == &::google::protobuf::internal::kEmptyString) {
    brand_ = new ::std::string;
  }
  brand_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CarlifeDeviceInfo::mutable_brand() {
  set_has_brand();
  if (brand_ == &::google::protobuf::internal::kEmptyString) {
    brand_ = new ::std::string;
  }
  return brand_;
}
inline ::std::string* CarlifeDeviceInfo::release_brand() {
  clear_has_brand();
  if (brand_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brand_;
    brand_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CarlifeDeviceInfo::set_allocated_brand(::std::string* brand) {
  if (brand_ != &::google::protobuf::internal::kEmptyString) {
    delete brand_;
  }
  if (brand) {
    set_has_brand();
    brand_ = brand;
  } else {
    clear_has_brand();
    brand_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cpu_abi = 5;
inline bool CarlifeDeviceInfo::has_cpu_abi() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CarlifeDeviceInfo::set_has_cpu_abi() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CarlifeDeviceInfo::clear_has_cpu_abi() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CarlifeDeviceInfo::clear_cpu_abi() {
  if (cpu_abi_ != &::google::protobuf::internal::kEmptyString) {
    cpu_abi_->clear();
  }
  clear_has_cpu_abi();
}
inline const ::std::string& CarlifeDeviceInfo::cpu_abi() const {
  return *cpu_abi_;
}
inline void CarlifeDeviceInfo::set_cpu_abi(const ::std::string& value) {
  set_has_cpu_abi();
  if (cpu_abi_ == &::google::protobuf::internal::kEmptyString) {
    cpu_abi_ = new ::std::string;
  }
  cpu_abi_->assign(value);
}
inline void CarlifeDeviceInfo::set_cpu_abi(const char* value) {
  set_has_cpu_abi();
  if (cpu_abi_ == &::google::protobuf::internal::kEmptyString) {
    cpu_abi_ = new ::std::string;
  }
  cpu_abi_->assign(value);
}
inline void CarlifeDeviceInfo::set_cpu_abi(const char* value, size_t size) {
  set_has_cpu_abi();
  if (cpu_abi_ == &::google::protobuf::internal::kEmptyString) {
    cpu_abi_ = new ::std::string;
  }
  cpu_abi_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CarlifeDeviceInfo::mutable_cpu_abi() {
  set_has_cpu_abi();
  if (cpu_abi_ == &::google::protobuf::internal::kEmptyString) {
    cpu_abi_ = new ::std::string;
  }
  return cpu_abi_;
}
inline ::std::string* CarlifeDeviceInfo::release_cpu_abi() {
  clear_has_cpu_abi();
  if (cpu_abi_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cpu_abi_;
    cpu_abi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CarlifeDeviceInfo::set_allocated_cpu_abi(::std::string* cpu_abi) {
  if (cpu_abi_ != &::google::protobuf::internal::kEmptyString) {
    delete cpu_abi_;
  }
  if (cpu_abi) {
    set_has_cpu_abi();
    cpu_abi_ = cpu_abi;
  } else {
    clear_has_cpu_abi();
    cpu_abi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cpu_abi2 = 6;
inline bool CarlifeDeviceInfo::has_cpu_abi2() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CarlifeDeviceInfo::set_has_cpu_abi2() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CarlifeDeviceInfo::clear_has_cpu_abi2() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CarlifeDeviceInfo::clear_cpu_abi2() {
  if (cpu_abi2_ != &::google::protobuf::internal::kEmptyString) {
    cpu_abi2_->clear();
  }
  clear_has_cpu_abi2();
}
inline const ::std::string& CarlifeDeviceInfo::cpu_abi2() const {
  return *cpu_abi2_;
}
inline void CarlifeDeviceInfo::set_cpu_abi2(const ::std::string& value) {
  set_has_cpu_abi2();
  if (cpu_abi2_ == &::google::protobuf::internal::kEmptyString) {
    cpu_abi2_ = new ::std::string;
  }
  cpu_abi2_->assign(value);
}
inline void CarlifeDeviceInfo::set_cpu_abi2(const char* value) {
  set_has_cpu_abi2();
  if (cpu_abi2_ == &::google::protobuf::internal::kEmptyString) {
    cpu_abi2_ = new ::std::string;
  }
  cpu_abi2_->assign(value);
}
inline void CarlifeDeviceInfo::set_cpu_abi2(const char* value, size_t size) {
  set_has_cpu_abi2();
  if (cpu_abi2_ == &::google::protobuf::internal::kEmptyString) {
    cpu_abi2_ = new ::std::string;
  }
  cpu_abi2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CarlifeDeviceInfo::mutable_cpu_abi2() {
  set_has_cpu_abi2();
  if (cpu_abi2_ == &::google::protobuf::internal::kEmptyString) {
    cpu_abi2_ = new ::std::string;
  }
  return cpu_abi2_;
}
inline ::std::string* CarlifeDeviceInfo::release_cpu_abi2() {
  clear_has_cpu_abi2();
  if (cpu_abi2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cpu_abi2_;
    cpu_abi2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CarlifeDeviceInfo::set_allocated_cpu_abi2(::std::string* cpu_abi2) {
  if (cpu_abi2_ != &::google::protobuf::internal::kEmptyString) {
    delete cpu_abi2_;
  }
  if (cpu_abi2) {
    set_has_cpu_abi2();
    cpu_abi2_ = cpu_abi2;
  } else {
    clear_has_cpu_abi2();
    cpu_abi2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string device = 7;
inline bool CarlifeDeviceInfo::has_device() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CarlifeDeviceInfo::set_has_device() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CarlifeDeviceInfo::clear_has_device() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CarlifeDeviceInfo::clear_device() {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    device_->clear();
  }
  clear_has_device();
}
inline const ::std::string& CarlifeDeviceInfo::device() const {
  return *device_;
}
inline void CarlifeDeviceInfo::set_device(const ::std::string& value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void CarlifeDeviceInfo::set_device(const char* value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void CarlifeDeviceInfo::set_device(const char* value, size_t size) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CarlifeDeviceInfo::mutable_device() {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  return device_;
}
inline ::std::string* CarlifeDeviceInfo::release_device() {
  clear_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_;
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CarlifeDeviceInfo::set_allocated_device(::std::string* device) {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    delete device_;
  }
  if (device) {
    set_has_device();
    device_ = device;
  } else {
    clear_has_device();
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string display = 8;
inline bool CarlifeDeviceInfo::has_display() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CarlifeDeviceInfo::set_has_display() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CarlifeDeviceInfo::clear_has_display() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CarlifeDeviceInfo::clear_display() {
  if (display_ != &::google::protobuf::internal::kEmptyString) {
    display_->clear();
  }
  clear_has_display();
}
inline const ::std::string& CarlifeDeviceInfo::display() const {
  return *display_;
}
inline void CarlifeDeviceInfo::set_display(const ::std::string& value) {
  set_has_display();
  if (display_ == &::google::protobuf::internal::kEmptyString) {
    display_ = new ::std::string;
  }
  display_->assign(value);
}
inline void CarlifeDeviceInfo::set_display(const char* value) {
  set_has_display();
  if (display_ == &::google::protobuf::internal::kEmptyString) {
    display_ = new ::std::string;
  }
  display_->assign(value);
}
inline void CarlifeDeviceInfo::set_display(const char* value, size_t size) {
  set_has_display();
  if (display_ == &::google::protobuf::internal::kEmptyString) {
    display_ = new ::std::string;
  }
  display_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CarlifeDeviceInfo::mutable_display() {
  set_has_display();
  if (display_ == &::google::protobuf::internal::kEmptyString) {
    display_ = new ::std::string;
  }
  return display_;
}
inline ::std::string* CarlifeDeviceInfo::release_display() {
  clear_has_display();
  if (display_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = display_;
    display_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CarlifeDeviceInfo::set_allocated_display(::std::string* display) {
  if (display_ != &::google::protobuf::internal::kEmptyString) {
    delete display_;
  }
  if (display) {
    set_has_display();
    display_ = display;
  } else {
    clear_has_display();
    display_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fingerprint = 9;
inline bool CarlifeDeviceInfo::has_fingerprint() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CarlifeDeviceInfo::set_has_fingerprint() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CarlifeDeviceInfo::clear_has_fingerprint() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CarlifeDeviceInfo::clear_fingerprint() {
  if (fingerprint_ != &::google::protobuf::internal::kEmptyString) {
    fingerprint_->clear();
  }
  clear_has_fingerprint();
}
inline const ::std::string& CarlifeDeviceInfo::fingerprint() const {
  return *fingerprint_;
}
inline void CarlifeDeviceInfo::set_fingerprint(const ::std::string& value) {
  set_has_fingerprint();
  if (fingerprint_ == &::google::protobuf::internal::kEmptyString) {
    fingerprint_ = new ::std::string;
  }
  fingerprint_->assign(value);
}
inline void CarlifeDeviceInfo::set_fingerprint(const char* value) {
  set_has_fingerprint();
  if (fingerprint_ == &::google::protobuf::internal::kEmptyString) {
    fingerprint_ = new ::std::string;
  }
  fingerprint_->assign(value);
}
inline void CarlifeDeviceInfo::set_fingerprint(const char* value, size_t size) {
  set_has_fingerprint();
  if (fingerprint_ == &::google::protobuf::internal::kEmptyString) {
    fingerprint_ = new ::std::string;
  }
  fingerprint_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CarlifeDeviceInfo::mutable_fingerprint() {
  set_has_fingerprint();
  if (fingerprint_ == &::google::protobuf::internal::kEmptyString) {
    fingerprint_ = new ::std::string;
  }
  return fingerprint_;
}
inline ::std::string* CarlifeDeviceInfo::release_fingerprint() {
  clear_has_fingerprint();
  if (fingerprint_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fingerprint_;
    fingerprint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CarlifeDeviceInfo::set_allocated_fingerprint(::std::string* fingerprint) {
  if (fingerprint_ != &::google::protobuf::internal::kEmptyString) {
    delete fingerprint_;
  }
  if (fingerprint) {
    set_has_fingerprint();
    fingerprint_ = fingerprint;
  } else {
    clear_has_fingerprint();
    fingerprint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string hardware = 10;
inline bool CarlifeDeviceInfo::has_hardware() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CarlifeDeviceInfo::set_has_hardware() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CarlifeDeviceInfo::clear_has_hardware() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CarlifeDeviceInfo::clear_hardware() {
  if (hardware_ != &::google::protobuf::internal::kEmptyString) {
    hardware_->clear();
  }
  clear_has_hardware();
}
inline const ::std::string& CarlifeDeviceInfo::hardware() const {
  return *hardware_;
}
inline void CarlifeDeviceInfo::set_hardware(const ::std::string& value) {
  set_has_hardware();
  if (hardware_ == &::google::protobuf::internal::kEmptyString) {
    hardware_ = new ::std::string;
  }
  hardware_->assign(value);
}
inline void CarlifeDeviceInfo::set_hardware(const char* value) {
  set_has_hardware();
  if (hardware_ == &::google::protobuf::internal::kEmptyString) {
    hardware_ = new ::std::string;
  }
  hardware_->assign(value);
}
inline void CarlifeDeviceInfo::set_hardware(const char* value, size_t size) {
  set_has_hardware();
  if (hardware_ == &::google::protobuf::internal::kEmptyString) {
    hardware_ = new ::std::string;
  }
  hardware_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CarlifeDeviceInfo::mutable_hardware() {
  set_has_hardware();
  if (hardware_ == &::google::protobuf::internal::kEmptyString) {
    hardware_ = new ::std::string;
  }
  return hardware_;
}
inline ::std::string* CarlifeDeviceInfo::release_hardware() {
  clear_has_hardware();
  if (hardware_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hardware_;
    hardware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CarlifeDeviceInfo::set_allocated_hardware(::std::string* hardware) {
  if (hardware_ != &::google::protobuf::internal::kEmptyString) {
    delete hardware_;
  }
  if (hardware) {
    set_has_hardware();
    hardware_ = hardware;
  } else {
    clear_has_hardware();
    hardware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string host = 11;
inline bool CarlifeDeviceInfo::has_host() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CarlifeDeviceInfo::set_has_host() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CarlifeDeviceInfo::clear_has_host() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CarlifeDeviceInfo::clear_host() {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    host_->clear();
  }
  clear_has_host();
}
inline const ::std::string& CarlifeDeviceInfo::host() const {
  return *host_;
}
inline void CarlifeDeviceInfo::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void CarlifeDeviceInfo::set_host(const char* value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void CarlifeDeviceInfo::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CarlifeDeviceInfo::mutable_host() {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  return host_;
}
inline ::std::string* CarlifeDeviceInfo::release_host() {
  clear_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CarlifeDeviceInfo::set_allocated_host(::std::string* host) {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cid = 12;
inline bool CarlifeDeviceInfo::has_cid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CarlifeDeviceInfo::set_has_cid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CarlifeDeviceInfo::clear_has_cid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CarlifeDeviceInfo::clear_cid() {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    cid_->clear();
  }
  clear_has_cid();
}
inline const ::std::string& CarlifeDeviceInfo::cid() const {
  return *cid_;
}
inline void CarlifeDeviceInfo::set_cid(const ::std::string& value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void CarlifeDeviceInfo::set_cid(const char* value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void CarlifeDeviceInfo::set_cid(const char* value, size_t size) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CarlifeDeviceInfo::mutable_cid() {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  return cid_;
}
inline ::std::string* CarlifeDeviceInfo::release_cid() {
  clear_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cid_;
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CarlifeDeviceInfo::set_allocated_cid(::std::string* cid) {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    delete cid_;
  }
  if (cid) {
    set_has_cid();
    cid_ = cid;
  } else {
    clear_has_cid();
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string manufacturer = 13;
inline bool CarlifeDeviceInfo::has_manufacturer() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CarlifeDeviceInfo::set_has_manufacturer() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CarlifeDeviceInfo::clear_has_manufacturer() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CarlifeDeviceInfo::clear_manufacturer() {
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    manufacturer_->clear();
  }
  clear_has_manufacturer();
}
inline const ::std::string& CarlifeDeviceInfo::manufacturer() const {
  return *manufacturer_;
}
inline void CarlifeDeviceInfo::set_manufacturer(const ::std::string& value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void CarlifeDeviceInfo::set_manufacturer(const char* value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void CarlifeDeviceInfo::set_manufacturer(const char* value, size_t size) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CarlifeDeviceInfo::mutable_manufacturer() {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  return manufacturer_;
}
inline ::std::string* CarlifeDeviceInfo::release_manufacturer() {
  clear_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = manufacturer_;
    manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CarlifeDeviceInfo::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    delete manufacturer_;
  }
  if (manufacturer) {
    set_has_manufacturer();
    manufacturer_ = manufacturer;
  } else {
    clear_has_manufacturer();
    manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string model = 14;
inline bool CarlifeDeviceInfo::has_model() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CarlifeDeviceInfo::set_has_model() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CarlifeDeviceInfo::clear_has_model() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CarlifeDeviceInfo::clear_model() {
  if (model_ != &::google::protobuf::internal::kEmptyString) {
    model_->clear();
  }
  clear_has_model();
}
inline const ::std::string& CarlifeDeviceInfo::model() const {
  return *model_;
}
inline void CarlifeDeviceInfo::set_model(const ::std::string& value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void CarlifeDeviceInfo::set_model(const char* value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void CarlifeDeviceInfo::set_model(const char* value, size_t size) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CarlifeDeviceInfo::mutable_model() {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  return model_;
}
inline ::std::string* CarlifeDeviceInfo::release_model() {
  clear_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = model_;
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CarlifeDeviceInfo::set_allocated_model(::std::string* model) {
  if (model_ != &::google::protobuf::internal::kEmptyString) {
    delete model_;
  }
  if (model) {
    set_has_model();
    model_ = model;
  } else {
    clear_has_model();
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string product = 15;
inline bool CarlifeDeviceInfo::has_product() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CarlifeDeviceInfo::set_has_product() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CarlifeDeviceInfo::clear_has_product() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CarlifeDeviceInfo::clear_product() {
  if (product_ != &::google::protobuf::internal::kEmptyString) {
    product_->clear();
  }
  clear_has_product();
}
inline const ::std::string& CarlifeDeviceInfo::product() const {
  return *product_;
}
inline void CarlifeDeviceInfo::set_product(const ::std::string& value) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::kEmptyString) {
    product_ = new ::std::string;
  }
  product_->assign(value);
}
inline void CarlifeDeviceInfo::set_product(const char* value) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::kEmptyString) {
    product_ = new ::std::string;
  }
  product_->assign(value);
}
inline void CarlifeDeviceInfo::set_product(const char* value, size_t size) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::kEmptyString) {
    product_ = new ::std::string;
  }
  product_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CarlifeDeviceInfo::mutable_product() {
  set_has_product();
  if (product_ == &::google::protobuf::internal::kEmptyString) {
    product_ = new ::std::string;
  }
  return product_;
}
inline ::std::string* CarlifeDeviceInfo::release_product() {
  clear_has_product();
  if (product_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = product_;
    product_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CarlifeDeviceInfo::set_allocated_product(::std::string* product) {
  if (product_ != &::google::protobuf::internal::kEmptyString) {
    delete product_;
  }
  if (product) {
    set_has_product();
    product_ = product;
  } else {
    clear_has_product();
    product_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string serial = 16;
inline bool CarlifeDeviceInfo::has_serial() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CarlifeDeviceInfo::set_has_serial() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CarlifeDeviceInfo::clear_has_serial() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CarlifeDeviceInfo::clear_serial() {
  if (serial_ != &::google::protobuf::internal::kEmptyString) {
    serial_->clear();
  }
  clear_has_serial();
}
inline const ::std::string& CarlifeDeviceInfo::serial() const {
  return *serial_;
}
inline void CarlifeDeviceInfo::set_serial(const ::std::string& value) {
  set_has_serial();
  if (serial_ == &::google::protobuf::internal::kEmptyString) {
    serial_ = new ::std::string;
  }
  serial_->assign(value);
}
inline void CarlifeDeviceInfo::set_serial(const char* value) {
  set_has_serial();
  if (serial_ == &::google::protobuf::internal::kEmptyString) {
    serial_ = new ::std::string;
  }
  serial_->assign(value);
}
inline void CarlifeDeviceInfo::set_serial(const char* value, size_t size) {
  set_has_serial();
  if (serial_ == &::google::protobuf::internal::kEmptyString) {
    serial_ = new ::std::string;
  }
  serial_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CarlifeDeviceInfo::mutable_serial() {
  set_has_serial();
  if (serial_ == &::google::protobuf::internal::kEmptyString) {
    serial_ = new ::std::string;
  }
  return serial_;
}
inline ::std::string* CarlifeDeviceInfo::release_serial() {
  clear_has_serial();
  if (serial_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serial_;
    serial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CarlifeDeviceInfo::set_allocated_serial(::std::string* serial) {
  if (serial_ != &::google::protobuf::internal::kEmptyString) {
    delete serial_;
  }
  if (serial) {
    set_has_serial();
    serial_ = serial;
  } else {
    clear_has_serial();
    serial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string codename = 17;
inline bool CarlifeDeviceInfo::has_codename() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CarlifeDeviceInfo::set_has_codename() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CarlifeDeviceInfo::clear_has_codename() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CarlifeDeviceInfo::clear_codename() {
  if (codename_ != &::google::protobuf::internal::kEmptyString) {
    codename_->clear();
  }
  clear_has_codename();
}
inline const ::std::string& CarlifeDeviceInfo::codename() const {
  return *codename_;
}
inline void CarlifeDeviceInfo::set_codename(const ::std::string& value) {
  set_has_codename();
  if (codename_ == &::google::protobuf::internal::kEmptyString) {
    codename_ = new ::std::string;
  }
  codename_->assign(value);
}
inline void CarlifeDeviceInfo::set_codename(const char* value) {
  set_has_codename();
  if (codename_ == &::google::protobuf::internal::kEmptyString) {
    codename_ = new ::std::string;
  }
  codename_->assign(value);
}
inline void CarlifeDeviceInfo::set_codename(const char* value, size_t size) {
  set_has_codename();
  if (codename_ == &::google::protobuf::internal::kEmptyString) {
    codename_ = new ::std::string;
  }
  codename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CarlifeDeviceInfo::mutable_codename() {
  set_has_codename();
  if (codename_ == &::google::protobuf::internal::kEmptyString) {
    codename_ = new ::std::string;
  }
  return codename_;
}
inline ::std::string* CarlifeDeviceInfo::release_codename() {
  clear_has_codename();
  if (codename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = codename_;
    codename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CarlifeDeviceInfo::set_allocated_codename(::std::string* codename) {
  if (codename_ != &::google::protobuf::internal::kEmptyString) {
    delete codename_;
  }
  if (codename) {
    set_has_codename();
    codename_ = codename;
  } else {
    clear_has_codename();
    codename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string incremental = 18;
inline bool CarlifeDeviceInfo::has_incremental() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CarlifeDeviceInfo::set_has_incremental() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CarlifeDeviceInfo::clear_has_incremental() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CarlifeDeviceInfo::clear_incremental() {
  if (incremental_ != &::google::protobuf::internal::kEmptyString) {
    incremental_->clear();
  }
  clear_has_incremental();
}
inline const ::std::string& CarlifeDeviceInfo::incremental() const {
  return *incremental_;
}
inline void CarlifeDeviceInfo::set_incremental(const ::std::string& value) {
  set_has_incremental();
  if (incremental_ == &::google::protobuf::internal::kEmptyString) {
    incremental_ = new ::std::string;
  }
  incremental_->assign(value);
}
inline void CarlifeDeviceInfo::set_incremental(const char* value) {
  set_has_incremental();
  if (incremental_ == &::google::protobuf::internal::kEmptyString) {
    incremental_ = new ::std::string;
  }
  incremental_->assign(value);
}
inline void CarlifeDeviceInfo::set_incremental(const char* value, size_t size) {
  set_has_incremental();
  if (incremental_ == &::google::protobuf::internal::kEmptyString) {
    incremental_ = new ::std::string;
  }
  incremental_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CarlifeDeviceInfo::mutable_incremental() {
  set_has_incremental();
  if (incremental_ == &::google::protobuf::internal::kEmptyString) {
    incremental_ = new ::std::string;
  }
  return incremental_;
}
inline ::std::string* CarlifeDeviceInfo::release_incremental() {
  clear_has_incremental();
  if (incremental_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = incremental_;
    incremental_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CarlifeDeviceInfo::set_allocated_incremental(::std::string* incremental) {
  if (incremental_ != &::google::protobuf::internal::kEmptyString) {
    delete incremental_;
  }
  if (incremental) {
    set_has_incremental();
    incremental_ = incremental;
  } else {
    clear_has_incremental();
    incremental_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string release = 19;
inline bool CarlifeDeviceInfo::has_release() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CarlifeDeviceInfo::set_has_release() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CarlifeDeviceInfo::clear_has_release() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CarlifeDeviceInfo::clear_release() {
  if (release_ != &::google::protobuf::internal::kEmptyString) {
    release_->clear();
  }
  clear_has_release();
}
inline const ::std::string& CarlifeDeviceInfo::release() const {
  return *release_;
}
inline void CarlifeDeviceInfo::set_release(const ::std::string& value) {
  set_has_release();
  if (release_ == &::google::protobuf::internal::kEmptyString) {
    release_ = new ::std::string;
  }
  release_->assign(value);
}
inline void CarlifeDeviceInfo::set_release(const char* value) {
  set_has_release();
  if (release_ == &::google::protobuf::internal::kEmptyString) {
    release_ = new ::std::string;
  }
  release_->assign(value);
}
inline void CarlifeDeviceInfo::set_release(const char* value, size_t size) {
  set_has_release();
  if (release_ == &::google::protobuf::internal::kEmptyString) {
    release_ = new ::std::string;
  }
  release_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CarlifeDeviceInfo::mutable_release() {
  set_has_release();
  if (release_ == &::google::protobuf::internal::kEmptyString) {
    release_ = new ::std::string;
  }
  return release_;
}
inline ::std::string* CarlifeDeviceInfo::release_release() {
  clear_has_release();
  if (release_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = release_;
    release_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CarlifeDeviceInfo::set_allocated_release(::std::string* release) {
  if (release_ != &::google::protobuf::internal::kEmptyString) {
    delete release_;
  }
  if (release) {
    set_has_release();
    release_ = release;
  } else {
    clear_has_release();
    release_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sdk = 20;
inline bool CarlifeDeviceInfo::has_sdk() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CarlifeDeviceInfo::set_has_sdk() {
  _has_bits_[0] |= 0x00080000u;
}
inline void CarlifeDeviceInfo::clear_has_sdk() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void CarlifeDeviceInfo::clear_sdk() {
  if (sdk_ != &::google::protobuf::internal::kEmptyString) {
    sdk_->clear();
  }
  clear_has_sdk();
}
inline const ::std::string& CarlifeDeviceInfo::sdk() const {
  return *sdk_;
}
inline void CarlifeDeviceInfo::set_sdk(const ::std::string& value) {
  set_has_sdk();
  if (sdk_ == &::google::protobuf::internal::kEmptyString) {
    sdk_ = new ::std::string;
  }
  sdk_->assign(value);
}
inline void CarlifeDeviceInfo::set_sdk(const char* value) {
  set_has_sdk();
  if (sdk_ == &::google::protobuf::internal::kEmptyString) {
    sdk_ = new ::std::string;
  }
  sdk_->assign(value);
}
inline void CarlifeDeviceInfo::set_sdk(const char* value, size_t size) {
  set_has_sdk();
  if (sdk_ == &::google::protobuf::internal::kEmptyString) {
    sdk_ = new ::std::string;
  }
  sdk_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CarlifeDeviceInfo::mutable_sdk() {
  set_has_sdk();
  if (sdk_ == &::google::protobuf::internal::kEmptyString) {
    sdk_ = new ::std::string;
  }
  return sdk_;
}
inline ::std::string* CarlifeDeviceInfo::release_sdk() {
  clear_has_sdk();
  if (sdk_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sdk_;
    sdk_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CarlifeDeviceInfo::set_allocated_sdk(::std::string* sdk) {
  if (sdk_ != &::google::protobuf::internal::kEmptyString) {
    delete sdk_;
  }
  if (sdk) {
    set_has_sdk();
    sdk_ = sdk;
  } else {
    clear_has_sdk();
    sdk_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 sdk_int = 21;
inline bool CarlifeDeviceInfo::has_sdk_int() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CarlifeDeviceInfo::set_has_sdk_int() {
  _has_bits_[0] |= 0x00100000u;
}
inline void CarlifeDeviceInfo::clear_has_sdk_int() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void CarlifeDeviceInfo::clear_sdk_int() {
  sdk_int_ = 0;
  clear_has_sdk_int();
}
inline ::google::protobuf::int32 CarlifeDeviceInfo::sdk_int() const {
  return sdk_int_;
}
inline void CarlifeDeviceInfo::set_sdk_int(::google::protobuf::int32 value) {
  set_has_sdk_int();
  sdk_int_ = value;
}

// optional string token = 22;
inline bool CarlifeDeviceInfo::has_token() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void CarlifeDeviceInfo::set_has_token() {
  _has_bits_[0] |= 0x00200000u;
}
inline void CarlifeDeviceInfo::clear_has_token() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void CarlifeDeviceInfo::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& CarlifeDeviceInfo::token() const {
  return *token_;
}
inline void CarlifeDeviceInfo::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CarlifeDeviceInfo::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CarlifeDeviceInfo::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CarlifeDeviceInfo::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* CarlifeDeviceInfo::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CarlifeDeviceInfo::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string btaddress = 23;
inline bool CarlifeDeviceInfo::has_btaddress() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void CarlifeDeviceInfo::set_has_btaddress() {
  _has_bits_[0] |= 0x00400000u;
}
inline void CarlifeDeviceInfo::clear_has_btaddress() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void CarlifeDeviceInfo::clear_btaddress() {
  if (btaddress_ != &::google::protobuf::internal::kEmptyString) {
    btaddress_->clear();
  }
  clear_has_btaddress();
}
inline const ::std::string& CarlifeDeviceInfo::btaddress() const {
  return *btaddress_;
}
inline void CarlifeDeviceInfo::set_btaddress(const ::std::string& value) {
  set_has_btaddress();
  if (btaddress_ == &::google::protobuf::internal::kEmptyString) {
    btaddress_ = new ::std::string;
  }
  btaddress_->assign(value);
}
inline void CarlifeDeviceInfo::set_btaddress(const char* value) {
  set_has_btaddress();
  if (btaddress_ == &::google::protobuf::internal::kEmptyString) {
    btaddress_ = new ::std::string;
  }
  btaddress_->assign(value);
}
inline void CarlifeDeviceInfo::set_btaddress(const char* value, size_t size) {
  set_has_btaddress();
  if (btaddress_ == &::google::protobuf::internal::kEmptyString) {
    btaddress_ = new ::std::string;
  }
  btaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CarlifeDeviceInfo::mutable_btaddress() {
  set_has_btaddress();
  if (btaddress_ == &::google::protobuf::internal::kEmptyString) {
    btaddress_ = new ::std::string;
  }
  return btaddress_;
}
inline ::std::string* CarlifeDeviceInfo::release_btaddress() {
  clear_has_btaddress();
  if (btaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = btaddress_;
    btaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CarlifeDeviceInfo::set_allocated_btaddress(::std::string* btaddress) {
  if (btaddress_ != &::google::protobuf::internal::kEmptyString) {
    delete btaddress_;
  }
  if (btaddress) {
    set_has_btaddress();
    btaddress_ = btaddress;
  } else {
    clear_has_btaddress();
    btaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace carlife
}  // namespace baidu
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CarlifeDeviceInfoProto_2eproto__INCLUDED
